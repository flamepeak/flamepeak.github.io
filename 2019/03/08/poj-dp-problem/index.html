
 <!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,400">
    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Inconsolata:400">
    <title>poj dp 问题 | FlamePeak</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="FlamePeak">
    

    
    <meta name="description" content="7625:三角形最佳路径问题查看 提交 统计 提问总时间限制: 1000ms 内存限制: 65536kB描述如下所示的由正整数数字构成的三角形: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，和最大的路径称为最佳路径。你的任务就是求出最佳路径上的数字之和。 注意：路径上的每一步只能从一个数走到下">
<meta name="keywords" content="C">
<meta property="og:type" content="article">
<meta property="og:title" content="poj dp 问题">
<meta property="og:url" content="http://flamepeak.com/2019/03/08/poj-dp-problem/index.html">
<meta property="og:site_name" content="FlamePeak">
<meta property="og:description" content="7625:三角形最佳路径问题查看 提交 统计 提问总时间限制: 1000ms 内存限制: 65536kB描述如下所示的由正整数数字构成的三角形: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，和最大的路径称为最佳路径。你的任务就是求出最佳路径上的数字之和。 注意：路径上的每一步只能从一个数走到下">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-03-25T17:38:18.206Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="poj dp 问题">
<meta name="twitter:description" content="7625:三角形最佳路径问题查看 提交 统计 提问总时间限制: 1000ms 内存限制: 65536kB描述如下所示的由正整数数字构成的三角形: 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，和最大的路径称为最佳路径。你的任务就是求出最佳路径上的数字之和。 注意：路径上的每一步只能从一个数走到下">

    
    <link rel="alternative" href="/atom.xml" title="FlamePeak" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
  <meta name="google-site-verification" content="rYNq4pSdFJQ3Ir4VuV4A6TqVEEUP8o-rrwmST28FhQY">
  <meta name="baidu-site-verification" content="AL6EYSh1WZ">
</head>
</html>
  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="FlamePeak">FlamePeak</a></h1>
				<h2 class="blog-motto">We know something, but we do not know more.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/notes">Notes</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:flamepeak.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2019/03/08/poj-dp-problem/" title="poj dp 问题" itemprop="url">poj dp 问题</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="FlamePeak" target="_blank" itemprop="author">FlamePeak</a>
		
  <p class="article-time">
    <time datetime="2019-03-08T08:13:47.000Z" itemprop="datePublished"> Published 2019-03-08</time>
    
  </p>
</header>
	<div class="article-content">
		
		<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7625:三角形最佳路径问题</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">如下所示的由正整数数字构成的三角形: </span><br><span class="line">7 </span><br><span class="line">3 8 </span><br><span class="line">8 1 0 </span><br><span class="line">2 7 4 4 </span><br><span class="line">4 5 2 6 5 </span><br><span class="line"></span><br><span class="line">从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，和最大的路径称为最佳路径。你的任务就是求出最佳路径上的数字之和。 </span><br><span class="line">注意：路径上的每一步只能从一个数走到下一层上和它最近的下边（正下方）的数或者右边（右下方）的数。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行为三角形高度100&gt;=h&gt;=1，同时也是最底层边的数字的数目。</span><br><span class="line">从第二行开始，每行为三角形相应行的数字，中间用空格分隔。</span><br><span class="line">输出</span><br><span class="line">最佳路径的长度数值。</span><br><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br><span class="line">或</span><br><span class="line">1</span><br><span class="line">8</span><br><span class="line">样例输出</span><br><span class="line">30</span><br><span class="line">或</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=h;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A[i][j];</span><br><span class="line">            dp[i][j] = A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = dp[i][j] + max(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1759:最长上升子序列</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 2000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">一个数的序列bi，当b1 &lt; b2 &lt; ... &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ..., aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 &lt;= i1 &lt; i2 &lt; ... &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8).</span><br><span class="line"></span><br><span class="line">你的任务，就是对于给定的序列，求出最长上升子序列的长度。</span><br><span class="line">输入</span><br><span class="line">输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。</span><br><span class="line">输出</span><br><span class="line">最长上升子序列的长度。</span><br><span class="line">样例输入</span><br><span class="line">7</span><br><span class="line">1 7 3 5 9 4 8</span><br><span class="line">样例输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Max=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[j])</span><br><span class="line">                dp[i] = max(dp[j]+<span class="number">1</span>, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;Max)</span><br><span class="line">            Max = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2000:最长公共子上升序列</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 10000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">给定两个整数序列，写一个程序求它们的最长上升公共子序列。</span><br><span class="line">当以下条件满足的时候，我们将长度为N的序列S1 , S2 , . . . , SN 称为长度为M的序列A1 , A2 , . . . , AM 的上升子序列：</span><br><span class="line"></span><br><span class="line">存在 1 &lt;= i1 &lt; i2 &lt; . . . &lt; iN &lt;= M ，使得对所有 1 &lt;= j &lt;=N，均有Sj = Aij，且对于所有的1 &lt;= j &lt; N，均有Sj &lt; Sj+1。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">每个序列用两行表示，第一行是长度M(1 &lt;= M &lt;= 500)，第二行是该序列的M个整数Ai (-231 &lt;= Ai &lt; 231 )</span><br><span class="line">输出</span><br><span class="line">在第一行，输出两个序列的最长上升公共子序列的长度L。在第二行，输出该子序列。如果有不止一个符合条件的子序列，则输出任何一个即可。</span><br><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">1 4 2 5 -12</span><br><span class="line">4</span><br><span class="line">-12 1 2 4</span><br><span class="line">样例输出</span><br><span class="line">2</span><br><span class="line">1 4</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">最长上升公共子序列</span></span><br><span class="line"><span class="comment">f(i1,i2)表示a1与a2[0..i2],以a1[i1]结尾的最长上升公共子序列</span></span><br><span class="line"><span class="comment">若a2[i2]==a1[i1],</span></span><br><span class="line"><span class="comment">f(i1,i2)=max&#123; f(i,i2-1) &#125;+1    (0&lt;=i&lt;i1)</span></span><br><span class="line"><span class="comment">若a2[i2]&lt;a1[i1],f(i1,i2)不变</span></span><br><span class="line"><span class="comment">若a2[i2]&gt;a1[i1],f(i1,i2)不变,</span></span><br><span class="line"><span class="comment">    max&#123; f(i,i2) &#125;的值更新</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">510</span>;</span><br><span class="line"><span class="keyword">int</span> m1,m2,a1[maxn],a2[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv;</span><br><span class="line">&#125;ans[maxn],cur;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m1);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m1;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a1[i]);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;m2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m2;i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a2[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;maxn;i++)</span><br><span class="line">        ans[i].len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i2=<span class="number">0</span>;i2&lt;m2;i2++)&#123;</span><br><span class="line">        cur.len=<span class="number">0</span>; cur.iv.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">0</span>;i1&lt;m1;i1++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a2[i2]&gt;a1[i1]&amp;&amp;ans[i1].len&gt;cur.len)</span><br><span class="line">                cur=ans[i1];</span><br><span class="line">            <span class="keyword">if</span>(a2[i2]==a1[i1])&#123;</span><br><span class="line">                ans[i1]=cur;</span><br><span class="line">                ans[i1].len++;</span><br><span class="line">                ans[i1].iv.push_back(a1[i1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m1;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[p].len&lt;ans[i].len)</span><br><span class="line">            p=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans[p].len);</span><br><span class="line">    <span class="keyword">if</span>(ans[p].iv.size())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans[p].iv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;ans[p].iv.size();i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">" %d"</span>,ans[p].iv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/Always_ease/article/details/80502598" target="_blank" rel="noopener">参考</a></p>
<p><a href="https://blog.csdn.net/qq_35160381/article/details/80238280" target="_blank" rel="noopener">参考：最长公共子序列、最长上升子序列、最长公共上升子序列</a></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1775:采药</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">辰辰是个很有潜能、天资聪颖的孩子，他的梦想是称为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</span><br><span class="line"></span><br><span class="line">如果你是辰辰，你能完成这个任务吗？</span><br><span class="line">输入</span><br><span class="line">输入的第一行有两个整数T（1 &lt;= T &lt;= 1000）和M（1 &lt;= M &lt;= 100），T代表总共能够用来采药的时间，M代表山洞里的草药的数目。接下来的M行每行包括两个在1到100之间（包括1和100）的的整数，分别表示采摘某株草药的时间和这株草药的价值。</span><br><span class="line">输出</span><br><span class="line">输出只包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tim[<span class="number">1005</span>], value[<span class="number">1005</span>], dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, M, Max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tim[i]&gt;&gt;value[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=T;j&gt;=tim[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j-tim[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[T];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6262:流感传染</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">有一批易感人群住在网格状的宿舍区内，宿舍区为n*n的矩阵，每个格点为一个房间，房间里可能住人，也可能空着。在第一天，有些房间里的人得了流感，以后每天，得流感的人会使其邻居传染上流感，（已经得病的不变），空房间不会传染。请输出第m天得流感的人数。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行一个数字n，n不超过100，表示有n*n的宿舍房间。</span><br><span class="line">接下来的n行，每行n个字符，’.’表示第一天该房间住着健康的人，’#’表示该房间空着，’@’表示第一天该房间住着得流感的人。</span><br><span class="line">接下来的一行是一个整数m，m不超过100.</span><br><span class="line">输出</span><br><span class="line">输出第m天，得流感的人数</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">int</span> n, m, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= m; d++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i][j] == <span class="string">'!'</span>)</span><br><span class="line">                    a[i][j] = <span class="string">'@'</span>; <span class="comment">// 将前一天标记的人感染</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将感染人周围的人标记</span></span><br><span class="line">                <span class="keyword">if</span>(a[i][j] == <span class="string">'@'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i + <span class="number">1</span> &lt;n &amp;&amp; a[i + <span class="number">1</span>][j] == <span class="string">'.'</span>)</span><br><span class="line">                        a[i + <span class="number">1</span>][j]=<span class="string">'!'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; a[i][j - <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">                        a[i][j - <span class="number">1</span>] = <span class="string">'!'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n &amp;&amp; a[i][j + <span class="number">1</span>] == <span class="string">'.'</span>)</span><br><span class="line">                        a[i][j + <span class="number">1</span>]=<span class="string">'!'</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; a[i - <span class="number">1</span>][j] == <span class="string">'.'</span>)</span><br><span class="line">                        a[i - <span class="number">1</span>][j] = <span class="string">'!'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i][j] == <span class="string">'@'</span>)</span><br><span class="line">                sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1808:公共子序列</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">我们称序列Z = &lt; z1, z2, ..., zk &gt;是序列X = &lt; x1, x2, ..., xm &gt;的子序列当且仅当存在 严格上升 的序列&lt; i1, i2, ..., ik &gt;，使得对j = 1, 2, ... ,k, 有xij = zj。比如Z = &lt; a, b, f, c &gt; 是X = &lt; a, b, c, f, b, c &gt;的子序列。</span><br><span class="line"></span><br><span class="line">现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。</span><br><span class="line">输入</span><br><span class="line">输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。</span><br><span class="line">输出</span><br><span class="line">对每组输入数据，输出一行，给出两个序列的最大公共子序列的长度。</span><br><span class="line">样例输入</span><br><span class="line">abcfbc         abfcab</span><br><span class="line">programming    contest </span><br><span class="line">abcd           mnp</span><br><span class="line">样例输出</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> A[<span class="number">205</span>], B[<span class="number">205</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%s %s"</span>, (A+<span class="number">1</span>), (B+<span class="number">1</span>))!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> lenA = <span class="built_in">strlen</span>(A+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> lenB = <span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="number">205</span>*<span class="number">205</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lenA;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=lenB;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]==B[j])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[lenA][lenB]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1944:吃糖果</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">名名的妈妈从外地出差回来，带了一盒好吃又精美的巧克力给名名（盒内共有 N 块巧克力，20 &gt; N &gt;0）。妈妈告诉名名每天可以吃一块或者两块巧克力。假设名名每天都吃巧克力，问名名共有多少种不同的吃完巧克力的方案。例如：如果N=1，则名名第1天就吃掉它，共有1种方案；如果N=2，则名名可以第1天吃1块，第2天吃1块，也可以第1天吃2块，共有2种方案；如果N=3，则名名第1天可以吃1块，剩2块，也可以第1天吃2块剩1块，所以名名共有2+1=3种方案；如果N=4，则名名可以第1天吃1块，剩3块，也可以第1天吃2块，剩2块，共有3+2=5种方案。现在给定N，请你写程序求出名名吃巧克力的方案数目。</span><br><span class="line">输入</span><br><span class="line">输入只有1行，即整数N。</span><br><span class="line">输出</span><br><span class="line">输出只有1行，即名名吃巧克力的方案数。</span><br><span class="line">样例输入</span><br><span class="line">4</span><br><span class="line">样例输出</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>这种题目如果实在不会就自己手动推导，找规律</p>
<p>本题实质是斐波那契数列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> remain)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(remain==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(remain==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> work(remain<span class="number">-1</span>) + work(remain<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;work(N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp的方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1996:登山</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 5000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">五一到了，PKU-ACM队组织大家去登山观光，队员们发现山上一个有N个景点，并且决定按照顺序来浏览这些景点，即每次所浏览景点的编号都要大于前一个浏览景点的编号。同时队员们还有另一个登山习惯，就是不连续浏览海拔相同的两个景点，并且一旦开始下山，就不再向上走了。队员们希望在满足上面条件的同时，尽可能多的浏览景点，你能帮他们找出最多可能浏览的景点数么？</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">Line 1： N (2 &lt;= N &lt;= 1000) 景点数</span><br><span class="line">Line 2： N个整数，每个景点的海拔</span><br><span class="line">输出</span><br><span class="line">最多能浏览的景点数</span><br><span class="line">样例输入</span><br><span class="line">8</span><br><span class="line">186 186 150 200 160 130 197 220</span><br><span class="line">样例输出</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1005</span></span><br><span class="line"><span class="keyword">int</span> n,ans;<span class="keyword">int</span> a[N],f1[N],f2[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f1[i]=f2[i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) f1[i]=max(f1[i],f1[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;i;j--)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;a[j]) f2[i]=max(f2[i],f2[j]+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans=max(f1[i]+f2[i]<span class="number">-1</span>,ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7627:鸡蛋的硬度</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">最近XX公司举办了一个奇怪的比赛：鸡蛋硬度之王争霸赛。参赛者是来自世 界各地的母鸡，比赛的内容是看谁下的蛋最硬，更奇怪的是XX公司并不使用什么精密仪器来测量蛋的硬度，他们采用了一种最老土的办法--从高度扔鸡蛋--来 测试鸡蛋的硬度，如果一次母鸡下的蛋从高楼的第a层摔下来没摔破，但是从a+1层摔下来时摔破了，那么就说这只母鸡的鸡蛋的硬度是a。你当然可以找出各种 理由说明这种方法不科学，比如同一只母鸡下的蛋硬度可能不一样等等，但是这不影响XX公司的争霸赛，因为他们只是为了吸引大家的眼球，一个个鸡蛋从100 层的高楼上掉下来的时候，这情景还是能吸引很多人驻足观看的，当然，XX公司也绝不会忘记在高楼上挂一条幅，写上“XX公司”的字样--这比赛不过是XX 公司的一个另类广告而已。 </span><br><span class="line">勤于思考的小A总是能从一件事情中发现一个数学问题，这件事也不例外。“假如有很多同样硬度的鸡蛋，那么我可以用二分的办法用最少的次数测出鸡蛋 的硬度”，小A对自己的这个结论感到很满意，不过很快麻烦来了，“但是，假如我的鸡蛋不够用呢，比如我只有1个鸡蛋，那么我就不得不从第1层楼开始一层一 层的扔，最坏情况下我要扔100次。如果有2个鸡蛋，那么就从2层楼开始的地方扔……等等，不对，好像应该从1/3的地方开始扔才对，嗯，好像也不一定 啊……3个鸡蛋怎么办，4个，5个，更多呢……”，和往常一样，小A又陷入了一个思维僵局，与其说他是勤于思考，不如说他是喜欢自找麻烦。 </span><br><span class="line">好吧，既然麻烦来了，就得有人去解决，小A的麻烦就靠你来解决了：）</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入包括多组数据，每组数据一行，包含两个正整数n和m(1&lt;=n&lt;=100,1&lt;=m&lt;=10)，其中n表示楼的高度，m表示你现在拥有的鸡蛋个数，这些鸡蛋硬度相同（即它们从同样高的地方掉下来要么都摔碎要么都不碎），并且小于等于n。你可以假定硬度为x的鸡蛋从高度小于等于x的地方摔无论如何都不会碎（没摔碎的鸡蛋可以继续使用），而只要从比x高的地方扔必然会碎。</span><br><span class="line">对每组输入数据，你可以假定鸡蛋的硬度在0至n之间，即在n+1层扔鸡蛋一定会碎。</span><br><span class="line">输出</span><br><span class="line">对于每一组输入，输出一个整数，表示使用最优策略在最坏情况下所需要的扔鸡蛋次数。</span><br><span class="line">样例输入</span><br><span class="line">100 1</span><br><span class="line">100 2</span><br><span class="line">样例输出</span><br><span class="line">100</span><br><span class="line">14</span><br><span class="line">提示</span><br><span class="line">最优策略指在最坏情况下所需要的扔鸡蛋次数最少的策略。</span><br><span class="line">如果只有一个鸡蛋，你只能从第一层开始扔，在最坏的情况下，鸡蛋的硬度是100，所以需要扔100次。如果采用其他策略，你可能无法测出鸡蛋的硬度(比如你第一次在第二层的地方扔,结果碎了,这时你不能确定硬度是0还是1)，即在最坏情况下你需要扔无限次，所以第一组数据的答案是100。</span><br><span class="line">来源</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/m__hd/article/details/52525182" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用dp，首先我们先看样例2（因为样例1谁都会）。为什么是14呢？那我们设丢x次， </span><br><span class="line">如果x次碎了。那么就在1~x-1次试。否则我们就在x+x-1次试。最后我可以知道答案就是x（x+1）/2&lt;=100。求出来就是14了。 </span><br><span class="line">那么不是两个鸡蛋呢我们就试着枚举第x层。如果鸡蛋碎了那么我们就找下面一层，同时鸡蛋数-1。如果没碎那么就找n-x~x+1的位置。 </span><br><span class="line">然后帅气的dp方程就出来了f[i][j]=max(f[i-1][j-1],f[n-i][j])+1！！！</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">110</span>][<span class="number">11</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j]=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=i;k++)<span class="comment">//枚举</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=m;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    f[i][j]=min(f[i][j],max(f[k<span class="number">-1</span>][j<span class="number">-1</span>],f[i-k][j])+<span class="number">1</span>);<span class="comment">//dp</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[n][m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1768:最大子矩阵</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">已知矩阵的大小定义为矩阵中所有元素的和。给定一个矩阵，你的任务是找到最大的非空(大小至少是1 * 1)子矩阵。</span><br><span class="line"></span><br><span class="line">比如，如下4 * 4的矩阵</span><br><span class="line"></span><br><span class="line">0 -2 -7 0</span><br><span class="line">9 2 -6 2</span><br><span class="line">-4 1 -4 1</span><br><span class="line">-1 8 0 -2</span><br><span class="line"></span><br><span class="line">的最大子矩阵是</span><br><span class="line"></span><br><span class="line">9 2</span><br><span class="line">-4 1</span><br><span class="line">-1 8</span><br><span class="line"></span><br><span class="line">这个子矩阵的大小是15。</span><br><span class="line">输入</span><br><span class="line">输入是一个N * N的矩阵。输入的第一行给出N (0 &lt; N &lt;= 100)。再后面的若干行中，依次（首先从左到右给出第一行的N个整数，再从左到右给出第二行的N个整数……）给出矩阵中的N2个整数，整数之间由空白字符分隔（空格或者空行）。已知矩阵中整数的范围都在[-127, 127]。</span><br><span class="line">输出</span><br><span class="line">输出最大子矩阵的大小。</span><br><span class="line">样例输入</span><br><span class="line">4</span><br><span class="line">0 -2 -7 0 9 2 -6 2</span><br><span class="line">-4 1 -4  1 -1</span><br><span class="line"></span><br><span class="line">8  0 -2</span><br><span class="line">样例输出</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/12mango/p/6803315.html" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">看不懂啊。。。。</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> matrix[SIZE + <span class="number">1</span>][SIZE + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> rowsum[SIZE + <span class="number">1</span>][SIZE + <span class="number">1</span>]; <span class="comment">//rowsum[i][j]记录第 i 行前 j 个数的和</span></span><br><span class="line"><span class="keyword">int</span> m, n, i, j, first, last, area, ans;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    m=n;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;matrix[i][j]);</span><br><span class="line">    ans = matrix[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        rowsum[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            rowsum[i][j] = rowsum[i][j<span class="number">-1</span>]+matrix[i][j];</span><br><span class="line">    <span class="keyword">for</span> (first = <span class="number">1</span>; first &lt;= n; first++)</span><br><span class="line">        <span class="keyword">for</span> (last = first; last &lt;= n; last++) </span><br><span class="line">        &#123;</span><br><span class="line">            area=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                area += rowsum[i][last] -rowsum[i][first<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span> (area &gt; ans) ans = area;</span><br><span class="line">                <span class="keyword">if</span> (area &lt; <span class="number">0</span>) area = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><a href="http://noi.openjudge.cn/ch0206/2728/" target="_blank" rel="noopener">原题</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2728:摘花生</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">Hello Kitty 想摘点花生送给她喜欢的米老鼠。她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。Hello Kitty只能向东或向南走，不能向西或向北走。问Hello Kitty 最多能够摘到多少颗花生。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行是一个整数T，代表一共有多少组数据。1&lt;=T &lt;= 100</span><br><span class="line">接下来是T组数据。</span><br><span class="line"></span><br><span class="line">每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C ( 1&lt;= R,C &lt;=100)</span><br><span class="line">每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有 C 个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目 M ( 0&lt;= M &lt;= 1000)。</span><br><span class="line">输出</span><br><span class="line">对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。</span><br><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">3 4</span><br><span class="line">2 3</span><br><span class="line">2 3 4</span><br><span class="line">1 6 5</span><br><span class="line">样例输出</span><br><span class="line">8</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> A[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> B[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> R, C;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;R&gt;&gt;C;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;A[i][j];</span><br><span class="line">                B[i][j]=A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=C;j++)</span><br><span class="line">            B[<span class="number">1</span>][j] = B[<span class="number">1</span>][j]+B[<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=R;i++)</span><br><span class="line">            B[i][<span class="number">1</span>] = B[i][<span class="number">1</span>]+B[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=R;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=C;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                B[i][j] = max(B[i<span class="number">-1</span>][j], B[i][j<span class="number">-1</span>])+B[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;B[R][C]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn], A[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> R, C;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;R&gt;&gt;C;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(A, <span class="number">0</span>, <span class="keyword">sizeof</span>(A));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>]=A[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=R;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=C;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j]=max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+A[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[R][C]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2718:移动路线</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">×桌子上有一个m行n列的方格矩阵，将每个方格用坐标表示，行坐标从下到上依次递增，列坐标从左至右依次递增，左下角方格的坐标为(1,1)，则右上角方格的坐标为(m,n)。</span><br><span class="line">小明是个调皮的孩子，一天他捉来一只蚂蚁，不小心把蚂蚁的右脚弄伤了，于是蚂蚁只能向上或向右移动。小明把这只蚂蚁放在左下角的方格中，蚂蚁从</span><br><span class="line">左下角的方格中移动到右上角的方格中，每步移动一个方格。蚂蚁始终在方格矩阵内移动，请计算出不同的移动路线的数目。</span><br><span class="line">对于1行1列的方格矩阵，蚂蚁原地移动，移动路线数为1；对于1行2列（或2行1列）的方格矩阵，蚂蚁只需一次向右（或向上）移动，移动路线数也为1……对于一个2行3列的方格矩阵，如下图所示：</span><br><span class="line"></span><br><span class="line">-------------------</span><br><span class="line">|(2,1)|(2,2)|(2,3)|</span><br><span class="line">-------------------</span><br><span class="line">|(1,1)|(1,2)|(1,3)|</span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">蚂蚁共有3种移动路线：</span><br><span class="line">路线1：(1,1) → (1,2) → (1,3) → (2,3)</span><br><span class="line">路线2：(1,1) → (1,2) → (2,2) → (2,3)</span><br><span class="line">路线3：(1,1) → (2,1) → (2,2) → (2,3)</span><br><span class="line">输入</span><br><span class="line">输入只有一行，包括两个整数m和n（0&lt;m+n&lt;=20），代表方格矩阵的行数和列数，m、n之间用空格隔开</span><br><span class="line">输出</span><br><span class="line">输出只有一行，为不同的移动路线的数目。</span><br><span class="line">样例输入</span><br><span class="line">2 3</span><br><span class="line">样例输出</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> m, n, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==m&amp;&amp;j==n)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;m||j&gt;n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(i+<span class="number">1</span>,j);</span><br><span class="line">    dfs(i,j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这道题同样是找规律，根据下图我们可以发现（2，2）的路线数目等于（1，2）与（2，1）路线数目之后，而且其它也是类似的，可以找到规律是a[i][j]=a[i-1][j]+a[i] </span><br><span class="line"></span><br><span class="line">递推，某一个点只能从其左边或者下边走过来</span><br><span class="line">f[i][j]存储(i,j)这个点上的结果，即f[i][j]=f[i-1][j]+f[i][j-1]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,a[<span class="number">21</span>][<span class="number">21</span>],i,j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    a[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            a[i][j]+=a[i<span class="number">-1</span>][j]+a[i][j<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[m][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2985:数字组合</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">有n个正整数，找出其中和为t(t也是正整数)的可能的组合方式。如：</span><br><span class="line">n=5,5个数分别为1,2,3,4,5，t=5；</span><br><span class="line">那么可能的组合有5=1+4和5=2+3和5=5三种组合方式。</span><br><span class="line">输入</span><br><span class="line">输入的第一行是两个正整数n和t，用空格隔开，其中1&lt;=n&lt;=20,表示正整数的个数，t为要求的和(1&lt;=t&lt;=1000)</span><br><span class="line">接下来的一行是n个正整数，用空格隔开。</span><br><span class="line">输出</span><br><span class="line">和为t的不同的组合方式的数目。</span><br><span class="line">样例输入</span><br><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">样例输出</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">25</span>];</span><br><span class="line"><span class="keyword">int</span> n, t;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum==t)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;t||index==n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dfs(index+<span class="number">1</span>,sum);</span><br><span class="line">    dfs(index+<span class="number">1</span>, sum+A[index]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;t;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    sort(A, A+n);</span><br><span class="line">    dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>01背包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,t;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1005</span>],f[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//01背包</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">    f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=t;j&gt;=a[i];j--)</span><br><span class="line">        f[j]+=f[j-a[i]];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2988:计算字符串距离</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">对于两个不同的字符串，我们有一套操作方法来把他们变得相同，具体方法为：</span><br><span class="line">修改一个字符（如把“a”替换为“b”）</span><br><span class="line">删除一个字符（如把“traveling”变为“travelng”）</span><br><span class="line"></span><br><span class="line">比如对于“abcdefg”和“abcdef”两个字符串来说，我们认为可以通过增加/减少一个“g”的方式来达到目的。无论增加还是减少“g”，我们都仅仅需要一次操作。我们把这个操作所需要的次数定义为两个字符串的距离。 </span><br><span class="line">给定任意两个字符串，写出一个算法来计算出他们的距离。</span><br><span class="line">输入</span><br><span class="line">第一行有一个整数n。表示测试数据的组数，</span><br><span class="line">接下来共n行，每行两个字符串，用空格隔开。表示要计算距离的两个字符串</span><br><span class="line">字符串长度不超过1000。</span><br><span class="line">输出</span><br><span class="line">针对每一组测试数据输出一个整数，值为两个字符串的距离。</span><br><span class="line">样例输入</span><br><span class="line">3</span><br><span class="line">abcdefg  abcdef</span><br><span class="line">ab ab</span><br><span class="line">mnklj jlknm</span><br><span class="line">样例输出</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line"></span><br><span class="line">类似最长公共子序列，逐个比较两字符串内各个字符。</span><br><span class="line"></span><br><span class="line">定义f[i][j]为a中前i个，b中前j个字符的最小距离（题目显然是要求最小的距离）。</span><br><span class="line"></span><br><span class="line">如果相同，则不需修改任何东西，距离相当于这两个字符之前的字符串的距离；</span><br><span class="line"></span><br><span class="line">如果不同，有三种修改方式：</span><br><span class="line"></span><br><span class="line">  1.删除a串中当前第i个字符，距离为a串前i - 1个字符与b串前j个字符的距离再加修改一个字符的距离1；</span><br><span class="line"></span><br><span class="line">  2.删除b串中当前第j个字符，距离为b串前j - 1个字符与a串前i个字符的距离再加修改一个字符的距离1；</span><br><span class="line"></span><br><span class="line">  3.将a串第i个字符修改为b串第j个字符，变成相同的，与相同时转移方程相同，再加1；</span><br><span class="line"></span><br><span class="line">f[i][j] = (f[i - 1][j - 1]), (a[i] == b[j]) ||</span><br><span class="line"></span><br><span class="line">  ( min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1 ), (a[i] != b[j])</span><br><span class="line"></span><br><span class="line">但是！当不同时应先选择三种方式中距离最小的，最后再加一，这应该容易理解</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//http://noi.openjudge.cn/ch0206/2988/</span></span><br><span class="line"><span class="comment">//3种操作，a字符串删除一个，b字符串删除一个，直接改变字符</span></span><br><span class="line"><span class="comment">//关键是要对dp数组的第0行和第0列初始赋值 </span></span><br><span class="line"><span class="keyword">int</span> n,len1,len2,dp[<span class="number">1100</span>][<span class="number">1100</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">1100</span>],b[<span class="number">1100</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)dp[i][<span class="number">0</span>]=i;<span class="comment">//开始只循环到len-1,错了 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=len2;i++)dp[<span class="number">0</span>][i]=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;len2;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=min(min(dp[i+<span class="number">1</span>][j],dp[i][j+<span class="number">1</span>]),dp[i][j])+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;i+1&lt;&lt;" "&lt;&lt;j+1&lt;&lt;" "&lt;&lt;dp[i+1][j+1]&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[len1][len2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        len1=<span class="built_in">strlen</span>(a);</span><br><span class="line">        len2=<span class="built_in">strlen</span>(b);</span><br><span class="line">        f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2989:糖果</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">由于在维护世界和平的事务中做出巨大贡献，Dzx被赠予糖果公司2010年5月23日当天无限量糖果免费优惠券。在这一天，Dzx可以从糖果公司的N件产品中任意选择若干件带回家享用。糖果公司的N件产品每件都包含数量不同的糖果。Dzx希望他选择的产品包含的糖果总数是K的整数倍，这样他才能平均地将糖果分给帮助他维护世界和平的伙伴们。当然，在满足这一条件的基础上，糖果总数越多越好。Dzx最多能带走多少糖果呢？</span><br><span class="line">注意：Dzx只能将糖果公司的产品整件带走。</span><br><span class="line">输入</span><br><span class="line">第一行包含两个整数N(1&lt;=N&lt;=100)和K(1&lt;=K&lt;=100)</span><br><span class="line">以下N行每行1个整数，表示糖果公司该件产品中包含的糖果数目，不超过1000000</span><br><span class="line">输出</span><br><span class="line">符合要求的最多能达到的糖果总数，如果不能达到K的倍数这一要求，输出0</span><br><span class="line">样例输入</span><br><span class="line">5 7</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">样例输出</span><br><span class="line">14</span><br><span class="line">提示</span><br><span class="line">Dzx的选择是2+3+4+5=14，这样糖果总数是7的倍数，并且是总数最多的选择。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">正统做法是背包DP，不过若是直接套也不行，这里的糖果总数太多，时间和空间都不够用。所以在这里设f(i,j)=前i个糖果选一些构成j%k的最大值，函数里的j是mod k过的，这样优化后情况就会好很多。</span><br><span class="line">方程为f(i,j)=max(f(i-1,j), f(i-1,(j-a[i]%k+k)%k)+a[i] ); 边界为d[i][0]=0。答案即为d[n][0]。</span><br><span class="line">需要注意f(i,j)不能初始化为0</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-20</span>, <span class="keyword">sizeof</span>(dp));<span class="comment">//必须，-1会出错，背包九讲，恰好装满背包除了F[0]外，其它F[1--V]均设为-INF</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;K;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][(j-A[i]%K+K)%K]+A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3531:判断整除</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">一个给定的正整数序列，在每个数之前都插入+号或-号后计算它们的和。比如序列：1、2、4共有8种可能的序列：</span><br><span class="line">(+1) + (+2) + (+4) = 7</span><br><span class="line">(+1) + (+2) + (-4) = -1</span><br><span class="line">(+1) + (-2) + (+4) = 3</span><br><span class="line">(+1) + (-2) + (-4) = -5</span><br><span class="line">(-1) + (+2) + (+4) = 5</span><br><span class="line">(-1) + (+2) + (-4) = -3</span><br><span class="line">(-1) + (-2) + (+4) = 1</span><br><span class="line">(-1) + (-2) + (-4) = -7</span><br><span class="line">所有结果中至少有一个可被整数k整除，我们则称此正整数序列可被k整除。例如上述序列可以被3、5、7整除，而不能被2、4、6、8……整除。注意：0、-3、-6、-9……都可以认为是3的倍数。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入的第一行包含两个数：N（2 &lt; N &lt; 10000）和k(2 &lt; k&lt; 100)，其中N代表一共有N个数，k代表被除数。第二行给出序列中的N个整数，这些整数的取值范围都0到10000之间（可能重复）。</span><br><span class="line">输出</span><br><span class="line">如果此正整数序列可被k整除，则输出YES，否则输出NO。（注意：都是大写字母）</span><br><span class="line">样例输入</span><br><span class="line">3 2</span><br><span class="line">1 2 4</span><br><span class="line">样例输出</span><br><span class="line">NO</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(a%k+b%k)%k=(a+b)%k</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/Willendless/p/9322414.html" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10001</span>] = &#123; <span class="number">0</span> &#125;, n, k;</span><br><span class="line">    <span class="keyword">bool</span> f[<span class="number">10001</span>][<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//每个i得到的余数可能有正负两个值，用bool型 ;f[i][j]表示用前i个数计算能得到余数j</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        a[i] %= k;</span><br><span class="line">    &#125;</span><br><span class="line">    f[<span class="number">1</span>][a[<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">            <span class="keyword">if</span> (f[i - <span class="number">1</span>][j])</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][(j + a[i]) % k] = <span class="literal">true</span>;</span><br><span class="line">                f[i][(j - a[i] + k) % k] = <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="comment">//第一个%k避免下标出现负数 加法与%的交换律</span></span><br><span class="line">    <span class="keyword">if</span> (f[n][<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3532:最大上升子序列和</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">一个数的序列bi，当b1 &lt; b2 &lt; ... &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,aN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 &lt;= i1 &lt; i2 &lt; ... &lt; iK &lt;= N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中序列和最大为18，为子序列(1, 3, 5, 9)的和.</span><br><span class="line"></span><br><span class="line">你的任务，就是对于给定的序列，求出最大上升子序列和。注意，最长的上升子序列的和不一定是最大的，比如序列(100, 1, 2, 3)的最大上升子序列和为100，而最长上升子序列为(1, 2, 3)</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入的第一行是序列的长度N (1 &lt;= N &lt;= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000（可能重复）。</span><br><span class="line">输出</span><br><span class="line">最大上升子序列和</span><br><span class="line">样例输入</span><br><span class="line">7</span><br><span class="line">1 7 3 5 9 4 8</span><br><span class="line">样例输出</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Max=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">        dp[i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&gt;A[j])</span><br><span class="line">                dp[i]=max(dp[i], dp[j]+A[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;Max)</span><br><span class="line">            Max=dp[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Max;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4978:宠物小精灵之收服</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">宠物小精灵是一部讲述小智和他的搭档皮卡丘一起冒险的故事。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一天，小智和皮卡丘来到了小精灵狩猎场，里面有很多珍贵的野生宠物小精灵。小智也想收服其中的一些小精灵。然而，野生的小精灵并不那么容易被收服。对于每一个野生小精灵而言，小智可能需要使用很多个精灵球才能收服它，而在收服过程中，野生小精灵也会对皮卡丘造成一定的伤害（从而减少皮卡丘的体力）。当皮卡丘的体力小于等于0时，小智就必须结束狩猎（因为他需要给皮卡丘疗伤），而使得皮卡丘体力小于等于0的野生小精灵也不会被小智收服。当小智的精灵球用完时，狩猎也宣告结束。</span><br><span class="line"></span><br><span class="line">我们假设小智遇到野生小精灵时有两个选择：收服它，或者离开它。如果小智选择了收服，那么一定会扔出能够收服该小精灵的精灵球，而皮卡丘也一定会受到相应的伤害；如果选择离开它，那么小智不会损失精灵球，皮卡丘也不会损失体力。</span><br><span class="line"></span><br><span class="line">小智的目标有两个：主要目标是收服尽可能多的野生小精灵；如果可以收服的小精灵数量一样，小智希望皮卡丘受到的伤害越小（剩余体力越大），因为他们还要继续冒险。</span><br><span class="line"></span><br><span class="line">现在已知小智的精灵球数量和皮卡丘的初始体力，已知每一个小精灵需要的用于收服的精灵球数目和它在被收服过程中会对皮卡丘造成的伤害数目。请问，小智该如何选择收服哪些小精灵以达到他的目标呢？</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入数据的第一行包含三个整数：N(0 &lt; N &lt; 1000)，M(0 &lt; M &lt; 500)，K(0 &lt; K &lt; 100)，分别代表小智的精灵球数量、皮卡丘初始的体力值、野生小精灵的数量。</span><br><span class="line">之后的K行，每一行代表一个野生小精灵，包括两个整数：收服该小精灵需要的精灵球的数量，以及收服过程中对皮卡丘造成的伤害。</span><br><span class="line">输出</span><br><span class="line">输出为一行，包含两个整数：C，R，分别表示最多收服C个小精灵，以及收服C个小精灵时皮卡丘的剩余体力值最多为R。</span><br><span class="line">样例输入</span><br><span class="line">样例输入1：</span><br><span class="line">10 100 5</span><br><span class="line">7 10</span><br><span class="line">2 40</span><br><span class="line">2 50</span><br><span class="line">1 20</span><br><span class="line">4 20</span><br><span class="line"></span><br><span class="line">样例输入2：</span><br><span class="line">10 100 5</span><br><span class="line">8 110</span><br><span class="line">12 10</span><br><span class="line">20 10</span><br><span class="line">5 200</span><br><span class="line">1 110</span><br><span class="line">样例输出</span><br><span class="line">样例输出1：</span><br><span class="line">3 30</span><br><span class="line"></span><br><span class="line">样例输出2：</span><br><span class="line">0 100</span><br><span class="line">提示</span><br><span class="line">对于样例输入1：小智选择：(7,10) (2,40) (1,20) 这样小智一共收服了3个小精灵，皮卡丘受到了70点伤害，剩余100-70=30点体力。所以输出3 30</span><br><span class="line">对于样例输入2：小智一个小精灵都没法收服，皮卡丘也不会收到任何伤害，所以输出0 100</span><br></pre></td></tr></table></figure>
<p>二维背包，只不过最后处理体力值有些麻烦，其实只需要看与最大值相等的用体力最少方法即可</p>
<p>找到所剩的体力最大值判断<code>d[N][i]==d[N][M]</code>，i是最少消耗的体力值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">105</span>];<span class="comment">//需要的精灵球的数量</span></span><br><span class="line"><span class="keyword">int</span> B[<span class="number">105</span>];<span class="comment">//收服过程中对皮卡丘造成的伤害。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>][<span class="number">505</span>];<span class="comment">//d[i][j]代表：有i个球，j体力，最多能捕获多少精灵</span></span><br><span class="line"><span class="comment">//用了j个精灵球，耗费了k的体力</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, M, K;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;K;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i]&gt;&gt;B[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=K;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=N;j&gt;=A[i];j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=M;k&gt;=B[i];k--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j][k]=max(dp[j][k], dp[j-A[i]][k-B[i]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N][M]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=M;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[N][k]==dp[N][M])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> Min = k;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;M-Min;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4982:踩方格</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：</span><br><span class="line">a.    每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；</span><br><span class="line">b.    走过的格子立即塌陷无法再走第二次；</span><br><span class="line">c.    只能向北、东、西三个方向走；</span><br><span class="line">请问：如果允许在方格矩阵上走n步，共有多少种不同的方案。2种走法只要有一步不一样，即被认为是不同的方案。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">允许在方格上行走的步数n(n &lt;= 20)</span><br><span class="line">输出</span><br><span class="line">计算出的方案数量</span><br><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">样例输出</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第i步的北方向=上一步北方向数+上一步东西方向数  东西方向=上一步北方向*2+上一步东西方向</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上一步北方向数=上上步方向数和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以有 d[i]=d[i-1]+d[i-2]*2+(d[i-1]-d[i-2])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="comment">//dp[0]=0;</span></span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">3</span>;dp[<span class="number">2</span>]=<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=<span class="number">22</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>]*<span class="number">2</span> + (dp[i<span class="number">-1</span>]-dp[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6045:开餐馆</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">北大信息学院的同学小明毕业之后打算创业开餐馆.现在共有n 个地点可供选择。小明打算从中选择合适的位置开设一些餐馆。这 n 个地点排列在同一条直线上。我们用一个整数序列m1, m2, ... mn 来表示他们的相对位置。由于地段关系,开餐馆的利润会有所不同。我们用pi 表示在mi 处开餐馆的利润。为了避免自己的餐馆的内部竞争,餐馆之间的距离必须大于k。请你帮助小明选择一个总利润最大的方案。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">标准的输入包含若干组测试数据。输入第一行是整数T (1 &lt;= T &lt;= 1000) ，表明有T组测试数据。紧接着有T组连续的测试。每组测试数据有3行,</span><br><span class="line">第1行:地点总数 n (n &lt; 100), 距离限制 k (k &gt; 0 &amp;&amp; k &lt; 1000).</span><br><span class="line">第2行:n 个地点的位置m1 , m2, ... mn ( 1000000 &gt; mi &gt; 0 且为整数,升序排列)</span><br><span class="line">第3行:n 个地点的餐馆利润p1 , p2, ... pn ( 1000 &gt; pi &gt; 0 且为整数)</span><br><span class="line">输出</span><br><span class="line">对于每组测试数据可能的最大利润</span><br><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">3 11</span><br><span class="line">1 2 15</span><br><span class="line">10 2 30</span><br><span class="line">3 16</span><br><span class="line">1 2 15</span><br><span class="line">10 2 30</span><br><span class="line">样例输出</span><br><span class="line">40</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<p>转化成LIS：最长不下降子序列</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">105</span>], B[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k, Max=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;B[i];</span><br><span class="line">            dp[i]=B[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i]-A[j]&gt;k)</span><br><span class="line">                    dp[i]=max(dp[i],dp[j]+B[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Max=max(Max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6046:数据包的调度机制</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">随着 Internet的迅猛发展,多媒体技术和电子商务应用日益广泛,Internet上的服务质量</span><br><span class="line"></span><br><span class="line">(QoS,Qualityof Service)问题已越来越受到重视。网络中采用的数据包调度机制与网络的服务质量 QoS 有着密切的关系。研究表明传统的基于队列的调度机制已不能满足网络服务质量QoS 的需求。服务质量 QoS 取决于数据包的延迟。每一个数据包都有一个延迟惩罚值。由于数据包承载的数据不同,不同数据包的延迟惩罚值也可能不同。此外,数据包的延迟也和它的发送顺序有关。如果一个数据包被第K个发送,假设它的延迟惩罚值是D,则这个数据包的最终延迟是 (K - 1) * D。北京大学2012 级信息学院的同学在程序设计课堂上,设计了一种新的基于栈的数据包的调度算法。同学们通过栈的先进后出(Last in First out)的原理,改变数据包的发送顺序,以减小数据包的延迟总值。给定N 个等待调度的数据包,起始这N 个数据包排成一个队列等待发送。接着,这些数据包按序进栈,调度算法可以控制数据包的出栈顺序。因此通过栈,可以将后面的数据包先于前面的数据包发送出去。请你实现一个调度算法使N 个数据包的延迟总值最小。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">标准的输入包含若干组测试数据。输入第一行是整数T(1 &lt;= T &lt;= 1000)，表明有T组测试数据。紧接着有T组连续的测试。每一组测试数据的第1行是 N（N &lt;= 100）,表述数据包的个数。接着的 N 行,每一行是一个整数,第i 行表示数据包i的延迟惩罚值( &lt;=50 )。</span><br><span class="line">输出</span><br><span class="line">对于每组测试数据，输出最小的延迟总值。</span><br><span class="line">样例输入</span><br><span class="line">1</span><br><span class="line">5</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">样例输出</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/c1299401227/p/5351334.html" target="_blank" rel="noopener">参考</a></p>
<hr>
<p>dp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">5</span>]=&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">10</span> != <span class="number">0</span>||n==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=A[i];v&lt;=n;v++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[v]+=dp[v-A[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力, 可以AC</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,s,a,b,c,d;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n%<span class="number">10</span>!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(a=<span class="number">0</span>;a&lt;=n/<span class="number">10</span>;a++)</span><br><span class="line">      <span class="keyword">for</span>( b=<span class="number">0</span>;b&lt;=n/<span class="number">20</span>;b++)</span><br><span class="line">         <span class="keyword">for</span>( c=<span class="number">0</span>;c&lt;=n/<span class="number">50</span>;c++)</span><br><span class="line">           <span class="keyword">for</span>(d=<span class="number">0</span>;d&lt;=n/<span class="number">100</span>;d++)</span><br><span class="line">               <span class="keyword">if</span>(<span class="number">10</span>*a+<span class="number">20</span>*b+<span class="number">50</span>*c+<span class="number">100</span>*d==n)</span><br><span class="line">                   s++;</span><br><span class="line">                   <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7614:最低通行费</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">一个商人穿过一个 N*N 的正方形的网格，去参加一个非常重要的商务活动。他要从网格的左上角进，右下角出。每穿越中间1个小方格，都要花费1个单位时间。商人必须在(2N-1)个单位时间穿越出去。而在经过中间的每个小方格时，都需要缴纳一定的费用。</span><br><span class="line"></span><br><span class="line">这个商人期望在规定时间内用最少费用穿越出去。请问至少需要多少费用？</span><br><span class="line"></span><br><span class="line">注意：不能对角穿越各个小方格（即，只能向上下左右四个方向移动且不能离开网格）。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行是一个整数，表示正方形的宽度N (1 &lt;= N &lt; 100)；</span><br><span class="line">后面 N 行，每行 N 个不大于 100 的整数，为网格上每个小方格的费用。</span><br><span class="line">输出</span><br><span class="line">至少需要的费用。</span><br><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">1 4 6 8 10 </span><br><span class="line">2 5 7 15 17 </span><br><span class="line">6 8 9 18 20 </span><br><span class="line">10 11 12 19 21 </span><br><span class="line">20 23 25 29 33 </span><br><span class="line">样例输出</span><br><span class="line">109</span><br></pre></td></tr></table></figure>
<p>不要被2N-1吓到，分析一下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;A[i][j];</span><br><span class="line">            dp[i][j]=A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>]+=dp[i<span class="number">-1</span>][<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>][i]+=dp[<span class="number">1</span>][i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=min(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>])+dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N][N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7624:山区建小学</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">政府在某山区修建了一条道路，恰好穿越总共m个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为di（为正整数），其中，0 &lt; i &lt; m。为了提高山区的文化素质，政府又决定从m个村中选择n个村建小学（设 0 &lt; n &lt; = m &lt; 500 ）。请根据给定的m、n以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第1行为m和n，其间用空格间隔</span><br><span class="line">第2行为(m-1) 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line">10 3</span><br><span class="line">2 4 6 5 2 4 3 1 3</span><br><span class="line">表示在10个村庄建3所学校。第1个村庄与第2个村庄距离为2，第2个村庄与第3个村庄距离为4，第3个村庄与第4个村庄距离为6，...，第9个村庄到第10个村庄的距离为3。</span><br><span class="line">输出</span><br><span class="line">各村庄到最近学校的距离之和的最小值。</span><br><span class="line">样例输入</span><br><span class="line">10 2</span><br><span class="line">3 1 3 1 1 1 1 1 3</span><br><span class="line">样例输出</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, f[<span class="number">500</span>][<span class="number">500</span>], mi[<span class="number">500</span>][<span class="number">500</span>], i, j, a[<span class="number">1001</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：明显的动态规划，dp[i][j]表示在前i个村庄中间建立j个小学的花费，</span></span><br><span class="line"><span class="comment">就是在前面（1，k）建立j-1个小学，在（k+1，n）建立1个小学，</span></span><br><span class="line"><span class="comment">他们的花费最小，很显然想求dp[i][j],那么肯定要先求出dp[k][j - 1]，典型的动态规划</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    a[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;tmp;</span><br><span class="line">        a[i]=a[i<span class="number">-1</span>]+tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            f[i][j] = <span class="number">9999999</span>;<span class="comment">//赋为最大值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            mi[i][j] = mi[i][j - <span class="number">1</span>] + a[j] - a[(i + j) / <span class="number">2</span>];<span class="comment">//从第i个村庄到第j个村庄中只建一个小学的状态转移方程</span></span><br><span class="line">        f[i][<span class="number">1</span>] = mi[<span class="number">1</span>][i];<span class="comment">//状态转移方程的边界</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt;= m; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = j - <span class="number">1</span>; k &lt; i; k++)</span><br><span class="line">                f[i][j] = min(f[i][j], f[k][j - <span class="number">1</span>] + mi[k + <span class="number">1</span>][i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8462:大盗阿福</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">阿福是一名经验丰富的大盗。趁着月黑风高，阿福打算今晚洗劫一条街上的店铺。</span><br><span class="line"></span><br><span class="line">这条街上一共有 N 家店铺，每家店中都有一些现金。阿福事先调查得知，只有当他同时洗劫了两家相邻的店铺时，街上的报警系统才会启动，然后警察就会蜂拥而至。</span><br><span class="line"></span><br><span class="line">作为一向谨慎作案的大盗，阿福不愿意冒着被警察追捕的风险行窃。他想知道，在不惊动警察的情况下，他今晚最多可以得到多少现金？</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入的第一行是一个整数 T (T &lt;= 50) ，表示一共有 T 组数据。</span><br><span class="line">接下来的每组数据，第一行是一个整数 N (1 &lt;= N &lt;= 100, 000) ，表示一共有 N 家店铺。第二行是 N 个被空格分开的正整数，表示每一家店铺中的现金数量。每家店铺中的现金数量均不超过 1000 。</span><br><span class="line">输出</span><br><span class="line">对于每组数据，输出一行。该行包含一个整数，表示阿福在不惊动警察的情况下可以得到的现金数量。</span><br><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 8 2</span><br><span class="line">4</span><br><span class="line">10 7 6 14</span><br><span class="line">样例输出</span><br><span class="line">8</span><br><span class="line">24</span><br></pre></td></tr></table></figure>
<p>超时代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> N, Max=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            dp[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i<span class="number">-2</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i]=max(dp[i], dp[j]+a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            Max = max(Max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;Max&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> N, Max=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            dp[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=max(dp[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[N]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析思路：</p>
<p>f[i] = max(f[i-1], f[i-2]+a[i])</p>
<p>f[i-1]表示不抢这家店，f[i-2]+a[i]表示抢这家店</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8464:股票买卖</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">最近越来越多的人都投身股市，阿福也有点心动了。谨记着“股市有风险，入市需谨慎”，阿福决定先来研究一下简化版的股票买卖问题。</span><br><span class="line"></span><br><span class="line">假设阿福已经准确预测出了某只股票在未来 N 天的价格，他希望买卖两次，使得获得的利润最高。为了计算简单起见，利润的计算方式为卖出的价格减去买入的价格。</span><br><span class="line"></span><br><span class="line">同一天可以进行多次买卖。但是在第一次买入之后，必须要先卖出，然后才可以第二次买入。</span><br><span class="line"></span><br><span class="line">现在，阿福想知道他最多可以获得多少利润。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入的第一行是一个整数 T (T &lt;= 50) ，表示一共有 T 组数据。</span><br><span class="line">接下来的每组数据，第一行是一个整数 N (1 &lt;= N &lt;= 100, 000) ，表示一共有 N 天。第二行是 N 个被空格分开的整数，表示每天该股票的价格。该股票每天的价格的绝对值均不会超过 1,000,000 。</span><br><span class="line">输出</span><br><span class="line">对于每组数据，输出一行。该行包含一个整数，表示阿福能够获得的最大的利润。</span><br><span class="line">样例输入</span><br><span class="line">3</span><br><span class="line">7</span><br><span class="line">5 14 -2 4 9 3 17</span><br><span class="line">6</span><br><span class="line">6 8 7 4 1 -2</span><br><span class="line">4</span><br><span class="line">18 9 5 2</span><br><span class="line">样例输出</span><br><span class="line">28</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> dp1[maxn], dp2[maxn];</span><br><span class="line"><span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, N;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">        <span class="keyword">int</span> Max=-inf, Min=inf;</span><br><span class="line">        <span class="built_in">memset</span>(dp1, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp1));<span class="comment">//必须初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(dp2, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp2));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Min=min(a[i], Min);</span><br><span class="line">            dp1[i]=max(dp1[i<span class="number">-1</span>], a[i]-Min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=N;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            Max=max(a[i], Max);</span><br><span class="line">            dp2[i]=max(dp2[i+<span class="number">1</span>], Max-a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=max(ans, dp1[i]+dp2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：在大量数据读写时，必须用scanf,不然会超时，比如本题使用cin会超时。</p>
<p>思路：主要不好想到定义问题状态，一开始想枚举第一次股票交易的卖出时间【这样O(1)处理第一次买入时间，logN处理第二次最大利益（第二次交易实际上是取最大值，所以可以用堆维护）】，但T<em>N</em>logN就tle了。</p>
<p>正解是dp1(i)代表1-i天一次交易的最大收益；再dp2(i)代表i-n天的最大收益。</p>
<p>以dp1(i)  = max( dp1(i-1) , a[i]-prev[i] )，prev是最小前缀，dp2同理。</p>
<p>这样O(n)做完。</p>
<p><a href="https://blog.csdn.net/murmured/article/details/9532357" target="_blank" rel="noopener">类似题UVA 11078 Open Credit System</a></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8467:鸣人的影分身</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">在火影忍者的世界里，令敌人捉摸不透是非常关键的。我们的主角漩涡鸣人所拥有的一个招数——多重影分身之术——就是一个很好的例子。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">影分身是由鸣人身体的查克拉能量制造的，使用的查克拉越多，制造出的影分身越强。</span><br><span class="line"></span><br><span class="line">针对不同的作战情况，鸣人可以选择制造出各种强度的影分身，有的用来佯攻，有的用来发起致命一击。</span><br><span class="line"></span><br><span class="line">那么问题来了，假设鸣人的查克拉能量为M，他影分身的个数为N，那么制造影分身时有多少种（用K表示）不同的分配方法？（影分身可以被分配到0点查克拉能量）</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。</span><br><span class="line">输出</span><br><span class="line">对输入的每组数据M和N，用一行输出相应的K。</span><br><span class="line">样例输入</span><br><span class="line">1</span><br><span class="line">7 3</span><br><span class="line">样例输出</span><br><span class="line">8</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apple</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m)</span><br><span class="line">        <span class="keyword">return</span> apple(m, m);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=m)</span><br><span class="line">        <span class="keyword">return</span> apple(m, n<span class="number">-1</span>) + apple(m-n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> M, N;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;M&gt;&gt;N;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;apple(M, N)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：把分身看做盘子，查克拉看做苹果。本题是放苹果问题的变式</p>
<p>dp方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn+<span class="number">5</span>][maxn+<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=maxn;i++) f[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=maxn;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&lt;=i) f[i][j]=f[i][j<span class="number">-1</span>]+f[i-j][j];</span><br><span class="line">            <span class="keyword">else</span> f[i][j]=f[i][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[m][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8471:切割回文</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">阿福最近对回文串产生了非常浓厚的兴趣。</span><br><span class="line"></span><br><span class="line">如果一个字符串从左往右看和从右往左看完全相同的话，那么就认为这个串是一个回文串。例如，“abcaacba”是一个回文串，“abcaaba”则不是一个回文串。</span><br><span class="line"></span><br><span class="line">阿福现在强迫症发作，看到什么字符串都想要把它变成回文的。阿福可以通过切割字符串，使得切割完之后得到的子串都是回文的。</span><br><span class="line"></span><br><span class="line">现在阿福想知道他最少切割多少次就可以达到目的。例如，对于字符串“abaacca”，最少切割一次，就可以得到“aba”和“acca”这两个回文子串。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入的第一行是一个整数 T (T &lt;= 20) ，表示一共有 T 组数据。</span><br><span class="line">接下来的 T 行，每一行都包含了一个长度不超过的 1000 的字符串，且字符串只包含了小写字母。</span><br><span class="line">输出</span><br><span class="line">对于每组数据，输出一行。该行包含一个整数，表示阿福最少切割的次数，使得切割完得到的子串都是回文的。</span><br><span class="line">样例输入</span><br><span class="line">3</span><br><span class="line">abaacca</span><br><span class="line">abcd</span><br><span class="line">abcba</span><br><span class="line">样例输出</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">提示</span><br><span class="line">对于第一组样例，阿福最少切割 1 次，将原串切割为“aba”和“acca”两个回文子串。</span><br><span class="line">对于第二组样例，阿福最少切割 3 次，将原串切割为“a”、“b”、“c”、“d”这四个回文子串。</span><br><span class="line">对于第三组样例，阿福不需要切割，原串本身就是一个回文串。</span><br></pre></td></tr></table></figure>
<p>思路：<br>
dp[i]表示把前i个都变成回文串最少需要切割的次数。<br>
每次枚举在j后面切一刀，暴力判断(j+1,i)是否是回文，如果是，那就是要切割dp[j]+1次。取最小即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isHui</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> en)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(st&lt;en)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[st]!=str[en])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        st++;</span><br><span class="line">        en--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=(isHui(<span class="number">0</span>,i))?<span class="number">0</span>:i;<span class="comment">//dp[i]初始化</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(isHui(j+<span class="number">1</span>, i))</span><br><span class="line">                    dp[i]=min(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dp[str.size()<span class="number">-1</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8780:拦截导弹</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。</span><br><span class="line"></span><br><span class="line">输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数），计算这套系统最多能拦截多少导弹。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行是一个整数N（不超过15），表示导弹数。</span><br><span class="line">第二行包含N个整数，为导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数）。</span><br><span class="line">输出</span><br><span class="line">一个整数，表示最多能拦截的导弹数。</span><br><span class="line">样例输入</span><br><span class="line">8</span><br><span class="line">389 207 155 300 299 170 158 65</span><br><span class="line">样例输出</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">18</span>], A[<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, Max=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i]&lt;=A[j]&amp;&amp;dp[j]+<span class="number">1</span>&gt;dp[i])</span><br><span class="line">                dp[i]=dp[j]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Max=max(Max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8782:乘积最大</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">今年是国际数学联盟确定的“2000——世界数学年”，又恰逢我国著名数学家华罗庚先生诞辰90周年。在华罗庚先生的家乡江苏金坛，组织了一场别开生面的数学智力竞赛的活动，你的一个好朋友XZ也有幸得以参加。活动中，主持人给所有参加活动的选手出了这样一道题目：</span><br><span class="line"></span><br><span class="line">设有一个长度为N的数字串，要求选手使用K个乘号将它分成K+1个部分，找出一种分法，使得这K+1个部分的乘积能够为最大。</span><br><span class="line"></span><br><span class="line">同时，为了帮助选手能够正确理解题意，主持人还举了如下的一个例子：</span><br><span class="line"></span><br><span class="line">有一个数字串：312，当N=3，K=1时会有以下两种分法：</span><br><span class="line"></span><br><span class="line">1)  3*12=36</span><br><span class="line"></span><br><span class="line">2)  31*2=62</span><br><span class="line"></span><br><span class="line">这时，符合题目要求的结果是：31*2=62</span><br><span class="line"></span><br><span class="line">现在，请你帮助你的好朋友XZ设计一个程序，求得正确的答案。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">程序的输入共有两行：</span><br><span class="line">第一行共有2个自然数N，K（6≤N≤40，1≤K≤6）</span><br><span class="line">第二行是一个长度为N的数字串。</span><br><span class="line">输出</span><br><span class="line">输出所求得的最大乘积（一个自然数）。（保证最终答案不超过int范围）</span><br><span class="line">样例输入</span><br><span class="line">4 2</span><br><span class="line">1231</span><br><span class="line">样例输出</span><br><span class="line">62</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, K;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;K;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">        a[i][i]=ch-<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j]=a[i][j<span class="number">-1</span>]*<span class="number">10</span>+a[j][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        dp[i][<span class="number">0</span>]=a[<span class="number">1</span>][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=K;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">1</span>;p&lt;i;p++)</span><br><span class="line">                dp[i][j]=max(dp[i][j], dp[p][j<span class="number">-1</span>]*a[p+<span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N][K];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出本题就是一个划分问题，要求一个最优划分。</p>
<p>设<code>d[i][j]</code>表示到i为止划分成j个数的最大乘积，则有转移方程：</p>
<p><code>d[i][j]=max{d[k][j-1]*num[k+1][i]}</code></p>
<p><code>num[s][t]</code>是区间st所代表的数，可以离线求出以加快速度。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8785:装箱问题</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">有一个箱子容量为V（正整数，0&lt;=v&lt;=20000），同时有n个物品（0&lt; n&lt;=30），每个物品有一个体积（正整数）。</span><br><span class="line"></span><br><span class="line">要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行是一个整数V，表示箱子容量。</span><br><span class="line">第二行是一个整数n，表示物品数。</span><br><span class="line">接下来n行，每行一个正整数（不超过10000），分别表示这n个物品的各自体积。</span><br><span class="line">输出</span><br><span class="line">一个整数，表示箱子剩余空间。</span><br><span class="line">样例输入</span><br><span class="line">24</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">3</span><br><span class="line">12</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">7</span><br><span class="line">样例输出</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>标准的01背包</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> V, n, Max=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;V&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=a[i];v--)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[v]=max(dp[v], dp[v-a[i]]+a[i]);</span><br><span class="line">            Max=max(Max, dp[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;V-Max;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8786:方格取数</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">设有N*N的方格图(N&lt;=10),我们将其中的某些方格中填入正整数,而其他的方格中则放入数字0。如下图所示（见样例）：&lt; p=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">某人从图的左上角的A 点出发，可以向下行走，也可以向右走，直到到达右下角的B点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字0）。 此人从A点到B 点共走两次，试找出2条这样的路径，使得取得的数之和为最大。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">输入的第一行为一个整数N（表示N*N的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的0表示输入结束。</span><br><span class="line">输出</span><br><span class="line">只需输出一个整数，表示2条路径上取得的最大的和。</span><br><span class="line">样例输入</span><br><span class="line">8</span><br><span class="line">2 3 13</span><br><span class="line">2 6 6</span><br><span class="line">3 5 7</span><br><span class="line">4 4 14</span><br><span class="line">5 2 21 </span><br><span class="line">5 6 4</span><br><span class="line">6 3 15</span><br><span class="line">7 2 14</span><br><span class="line">0 0 0</span><br><span class="line">样例输出</span><br><span class="line">67</span><br><span class="line">来源</span><br><span class="line">NOIP2000复赛 提高组 第四题</span><br></pre></td></tr></table></figure>
<p><a href="http://noi.openjudge.cn/ch0206/8786/" target="_blank" rel="noopener">8786:方格取数</a></p>
<p>思路：</p>
<p><strong>多线程DP</strong> ，同时模拟两个人走。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">O(n^4)</span><br><span class="line">f[i][j][k][l]表示分别走到(i,j)和(k,l)的最大和。</span><br><span class="line">每次从上一步分别走(下,下),(右,右),(右,下),(下,右)的状态推导就好了。</span><br><span class="line">f[i][j][k][l]=max(f[i-1][j][k-1][l],f[i][j-1][k][l-1],f[i][j-1][k-1][l],f[i-1][j][k][l-1])+a[i][j]+a[k][l]-((i==j&amp;&amp;k==l)?a[k][l]:0);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn][maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> x,y,val;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;&amp;val==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a[x][y]=val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=N;r++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==k&amp;&amp;j==r)</span><br><span class="line">                        tmp=a[i][j];</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        tmp=<span class="number">0</span>;</span><br><span class="line">                    dp[i][j][k][r]=max( max(dp[i<span class="number">-1</span>][j][k<span class="number">-1</span>][r], dp[i][j<span class="number">-1</span>][k][r<span class="number">-1</span>]) ,max(dp[i<span class="number">-1</span>][j][k][r<span class="number">-1</span>], dp[i][j<span class="number">-1</span>][k<span class="number">-1</span>][r])) + a[i][j]+a[k][r] -tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N][N][N][N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8787:数的划分</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">将整数n分成k份，且每份不能为空，任意两份不能相同(不考虑顺序)。</span><br><span class="line"></span><br><span class="line">例如：n=7，k=3，下面三种分法被认为是相同的。</span><br><span class="line"></span><br><span class="line">1，1，5； 1，5，1； 5，1，1；</span><br><span class="line"></span><br><span class="line">问有多少种不同的分法。 输出：一个整数，即不同的分法。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">两个整数n，k (6 &lt; n &lt;= 200，2 &lt;= k &lt;= 6)，中间用单个空格隔开。</span><br><span class="line">输出</span><br><span class="line">一个整数，即不同的分法。</span><br><span class="line">样例输入</span><br><span class="line">7 3</span><br><span class="line">样例输出</span><br><span class="line">4</span><br><span class="line">提示</span><br><span class="line">四种分法为：1，1，5；1，2，4；1，3，3；2，2，3。</span><br><span class="line">来源</span><br><span class="line">NOIP2001复赛 提高组 第二题</span><br></pre></td></tr></table></figure>
<p>类似：放苹果问题，只不过要求不空，那就每一个盘子先放一个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">apple</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;m)</span><br><span class="line">        <span class="keyword">return</span> apple(m, m);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=m)</span><br><span class="line">        <span class="keyword">return</span> apple(m, n<span class="number">-1</span>) + apple(m-n, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;apple(n-k,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">90:滑雪</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 65536kB</span><br><span class="line">描述</span><br><span class="line">Michael喜欢滑雪百这并不奇怪， 因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael想知道载一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子</span><br><span class="line"> 1  2  3  4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br><span class="line"></span><br><span class="line">一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度减小。在上面的例子中，一条可滑行的滑坡为24-17-16-1。当然25-24-23-...-3-2-1更长。事实上，这是最长的一条。</span><br><span class="line">输入</span><br><span class="line">输入的第一行表示区域的行数R和列数C(1 &lt;= R,C &lt;= 100)。下面是R行，每行有C个整数，代表高度h，0&lt;=h&lt;=10000。</span><br><span class="line">输出</span><br><span class="line">输出最长区域的长度。</span><br><span class="line">样例输入</span><br><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br><span class="line">样例输出</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/Always_ease/article/details/80597777" target="_blank" rel="noopener">参考1</a></p>
<p><a href="https://www.cnblogs.com/jiasaidongqi/p/4320005.html" target="_blank" rel="noopener">参考2</a></p>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9265:取数游戏</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 10000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">我们来玩一个游戏：自然数1到N，按顺序列成一排，你可以从中取走任意个数，但是相邻的两个不可以同时被取走。如果你能算出一共有多少种取法，那么你会被天神Lijiganjun奖励。</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">仅包含一个数n（1&lt; n &lt; 50）。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">仅包含一个数———你的答案。</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">5</span><br><span class="line">样例输出</span><br><span class="line">13</span><br><span class="line">来源</span><br><span class="line">递推五十题</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可能很多人都知道是一个类似于斐波那契数列的东西，然后递推求解。但是估计很少人知道为什么，我钻研了一下，说说自己的见解。</span><br><span class="line"></span><br><span class="line">有一排数 1,2,..n-1,n</span><br><span class="line"></span><br><span class="line">f[i]表示(前)i个数取的方式数，现在已知f[n-1] f[n-2],求f[n]</span><br><span class="line"></span><br><span class="line">第n个数有两种状态，取或不取，如果取，那么n-1就不能取(题目条件)，所以方案数就是f[n-2](在此中每种方案里加一个4即可)，另一种是不取，那么就是f[n-1](3不一定取)，所以总的就是f[n]:=f[n-1]+f[n-2],证明完毕！</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> p[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    p[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">    p[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">        p[i]=p[i<span class="number">-1</span>]+p[i<span class="number">-2</span>];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;p[n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9267:核电站</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 5000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">一个核电站有N个放核物质的坑，坑排列在一条直线上。如果连续M个坑中放入核物质，则会发生爆炸，于是，在某些坑中可能不放核物质。</span><br><span class="line"></span><br><span class="line">任务：对于给定的N和M，求不发生爆炸的放置核物质的方案总数 </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">只一行，两个正整数N，M( 1 &lt; N &lt; 50，2 ≤ M ≤ 5 )</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个正整数S，表示方案总数。</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">4 3</span><br><span class="line">样例输出</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/qq_36183935/article/details/70548598" target="_blank" rel="noopener">参考</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[n]表示在n个坑中，每个坑都有两种可能，放或者不放，但不能有连续m个坑里都有物质</span><br><span class="line"></span><br><span class="line">从头开始向后放，每个坑都有两种可能，放或者不放</span><br><span class="line"></span><br><span class="line">开头前i个连续的坑中都有核物质（0&lt;=i&lt;=m-1)，则第i+1个坑必空。 i+1后面的坑再放和前面的就又没关系了</span><br><span class="line"></span><br><span class="line">i=0时的放法为dp[n-1]； 在后n-1个坑中，每个坑都有两种可能，放或者不放，但不能有连续m个坑里都有物质 </span><br><span class="line">i=1时的放法为dp[n-2]； 在后n-2个坑中………… </span><br><span class="line">……………………； </span><br><span class="line">i=m-1时的放法为dp[n-m]。 在后n-m个坑中…………</span><br><span class="line"></span><br><span class="line">得dp[n]=dp[n-1]+dp[n-2]+……+dp[n-m] 。</span><br><span class="line"></span><br><span class="line">当n&lt;=m-1时： dp[n]=2*dp[n-1] (无论放还是不放，都不会有连续m个坑里都有)</span><br><span class="line"></span><br><span class="line">当n==m时： dp[n]=2*dp[n-1] -1（减去每个坑里都有核物质这种情况）</span><br><span class="line"></span><br><span class="line">当n&gt;m时： </span><br><span class="line">dp[n]=dp[n-1]+dp[n-2]+……+dp[n-m] </span><br><span class="line">dp[n-1]=dp[n-2]+……+dp[n-m] </span><br><span class="line">两式相减得： </span><br><span class="line">dp[n]=dp[n-1]*2-dp[n-m-1]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[<span class="number">55</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N, m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;m;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i==m)</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]*<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]*<span class="number">2</span>-dp[i-m<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9268:酒鬼</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 2000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">Santo刚刚与房东打赌赢得了一间在New Clondike 的大客厅。今天，他来到这个大客厅欣赏他的奖品。房东摆出了一行瓶子在酒吧上。瓶子里都装有不同体积的酒。令Santo高兴的是，瓶子中的酒都有不同的味道。房东说道：“你可以喝尽可能多的酒，但是一旦打开酒盖你就必须把它喝完，喝完一瓶后把它放回原处。还有一件最重要的事，你必须从左至右依次喝，并且不能连续超过三瓶，不然会给你带来坏运气。”现在可怜的Santo站在酒吧前努力的想着，他到底应该喝哪几瓶才能使喝的酒最多呢？请帮助他找出他应该喝的酒瓶号，因为思考让他感到不安。 </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">第一行一个整数N,有N个酒瓶。N&lt;=700接下有N行，第I+1行的数字代表酒瓶I中酒的体积。</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">一个数字，喝的酒的最大总体积。遵守以上规则，使得三个连续瓶子中至少一个瓶子是满的。</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">6</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">9</span><br><span class="line">8</span><br><span class="line">1</span><br><span class="line">样例输出</span><br><span class="line">33</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">705</span>], dp[<span class="number">705</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    dp[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>]=dp[<span class="number">1</span>]+a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i]=max(dp[i<span class="number">-1</span>], max(dp[i<span class="number">-2</span>]+a[i], dp[i<span class="number">-3</span>]+a[i]+a[i<span class="number">-1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">思路：</span><br><span class="line"></span><br><span class="line">d[i]的意思是分析到第i个酒瓶时所能喝的最多酒。</span><br><span class="line"></span><br><span class="line">状态转移方程为：</span><br><span class="line"></span><br><span class="line">d[i] = max(d[i - 1], max(d[i - 2] + a[i], d[i - 3] + a[i] + a[i - 1]));</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9271:奶牛散步</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 10000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">从一个无限大的矩阵的中心点出发，一步只能向右走、向上走或向左走。恰好走N步且不经过已走的点 </span><br><span class="line">共有多少种走法？ </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">一个数字，代表N,N&lt;=1000</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">输出有多少方案, 模12345</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">样例输出</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;N;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">3</span>;</span><br><span class="line">    dp[<span class="number">2</span>]=<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=N;i++)</span><br><span class="line">        dp[i]=(dp[i<span class="number">-1</span>]*<span class="number">2</span> + dp[i<span class="number">-2</span>])%<span class="number">12345</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[N];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9272:偶数个数字3</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 10000ms 单个测试点时间限制: 1000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">在所有的N位数中，有多少个数中有偶数个数字3？</span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">一行给出数字N，N&lt;=1000</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">如题</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">2</span><br><span class="line">样例输出</span><br><span class="line">73</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f[i][j]表示i位数中含数字3的个数模2为j的个数。于是分第i位填3还是不填3讨论。</span><br><span class="line"></span><br><span class="line">dp[i][1]表示i位数有奇数个三的数量，</span><br><span class="line">dp[i][0]表示有偶数个三的数量。</span><br><span class="line">dp[i][1]可以从dp[i-1][1]首位添加0 1 2 4 5 6 7 8 9和dp[i-1][0]首位添加3转移，dp[i][0]同理。</span><br><span class="line">注意当i==N时首位不能添加0</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1010</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">用dp[i][1]表示i位数有奇数个三的数量，</span></span><br><span class="line"><span class="comment">dp[i][0]表示有偶数个三的数量。</span></span><br><span class="line"><span class="comment">dp[i][1]可以从dp[i-1][1]首位添加0 1 2 4 5 6 7 8 9和dp[i-1][0]首位添加3转移，</span></span><br><span class="line"><span class="comment">dp[i][0]同理。注意当i==N时首位不能添加0。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = i==N?<span class="number">8</span>:<span class="number">9</span>;</span><br><span class="line">        dp[i][<span class="number">0</span>]=(dp[i<span class="number">-1</span>][<span class="number">0</span>]*k+dp[i<span class="number">-1</span>][<span class="number">1</span>])%<span class="number">12345</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>]=(dp[i<span class="number">-1</span>][<span class="number">1</span>]*k+dp[i<span class="number">-1</span>][<span class="number">0</span>])%<span class="number">12345</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[N][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9277:Logs Stacking堆木头</span><br><span class="line">查看 提交 统计 提问</span><br><span class="line">总时间限制: 1000ms 内存限制: 131072kB</span><br><span class="line">描述</span><br><span class="line">Daxinganling produces a lot of timber. Before loading onto trains, the timberjacks will place the logs to some place in the open air first. Looking from the sideway, the figure of a logs stack is as follows: </span><br><span class="line">We have known that the number of logs in each layer is fewer than the lower layer for at least one log, and that in each layer the logs are connected in a line. In the figure above, there are 12 logs in the bottom layer of the stack. Now, given the number of logs in the bottom layer, the timberjacks want to know how many possible figures there may be. </span><br><span class="line">给出在最底层的木头的个数，问有多少种堆放木头的方式，当然你的堆放方式不能让木头掉下来. </span><br><span class="line">在堆放的时候木头必须互相挨着在一起. </span><br><span class="line"></span><br><span class="line">输入</span><br><span class="line">The first line of input contains the number of test cases T (1 &lt;= T &lt;= 1000000). Then T lines follow. Every line only contains a number n (1 &lt;= n &lt;= 200000) representing the number of logs in the bottom layer.</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line">For each test case in the input, you should output the corresponding number of possible figures. Because the number may be very large, just output the number mod 10^5.</span><br><span class="line"></span><br><span class="line">样例输入</span><br><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">样例输出</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">34</span><br><span class="line">提示</span><br><span class="line">当输入3时，有5种方式</span><br><span class="line"></span><br><span class="line">第一种：上面一个也不放</span><br><span class="line"></span><br><span class="line">第二种：上面放一根，放在最左边</span><br><span class="line"></span><br><span class="line">第三种：上面放一根，放在最右边</span><br><span class="line"></span><br><span class="line">第四种：上面放二根</span><br><span class="line"></span><br><span class="line">第五种：上面先放二根，然后在二根的上面放一根</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/reddest/p/6003665.html" target="_blank" rel="noopener">参考</a></p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/C/">C</a>
  </div>

</div>


	<div class="article-share" id="share">
	
	  <div data-url="http://flamepeak.com/2019/03/08/poj-dp-problem/" data-title="poj dp 问题 | FlamePeak" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2019/03/10/poj-search/" title="poj search">
  <strong>上一篇：</strong><br/>
  <span>
  poj search</span>
</a>
</div>


<div class="next">
<a href="/2019/03/07/poj-recursion-examples/"  title="poj 递归">
 <strong>下一篇：</strong><br/> 
 <span>poj 递归
</span>
</a>
</div>

</nav>

	

</div>  

      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
 
 
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  
<div class="categorieslist">
	<p class="asidetitle">Categories</p>
		<ul>
		
		  
			<li><a href="/categories/Android/" title="Android">Android<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Cryptography/" title="Cryptography">Cryptography<sup>15</sup></a></li>
		  
		
		  
			<li><a href="/categories/Hardware/" title="Hardware">Hardware<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Life/" title="Life">Life<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>40</sup></a></li>
		  
		
		  
			<li><a href="/categories/Network-Security/" title="Network Security">Network Security<sup>19</sup></a></li>
		  
		
		  
			<li><a href="/categories/Python/" title="Python">Python<sup>35</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tools/" title="Tools">Tools<sup>17</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web前端/" title="Web前端">Web前端<sup>20</sup></a></li>
		  
		
		  
			<li><a href="/categories/Web后端/" title="Web后端">Web后端<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/人工智能/" title="人工智能">人工智能<sup>7</sup></a></li>
		  
		
		  
			<li><a href="/categories/百家杂谈/" title="百家杂谈">百家杂谈<sup>21</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Python/" title="Python">Python<sup>38</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>31</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>21</sup></a></li>
			
		
			
				<li><a href="/tags/笔记/" title="笔记">笔记<sup>18</sup></a></li>
			
		
			
				<li><a href="/tags/cryptography/" title="cryptography">cryptography<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Hexo/" title="Hexo">Hexo<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Life/" title="Life">Life<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/JavaScript/" title="JavaScript">JavaScript<sup>9</sup></a></li>
			
		
			
				<li><a href="/tags/MongoDB/" title="MongoDB">MongoDB<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Mysql/" title="Mysql">Mysql<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Network-Security/" title="Network Security">Network Security<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Kali/" title="Kali">Kali<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Scrapy/" title="Scrapy">Scrapy<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/Docker/" title="Docker">Docker<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/VPN/" title="VPN">VPN<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/读书/" title="读书">读书<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/人生/" title="人生">人生<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Tools/" title="Tools">Tools<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Chrome/" title="Chrome">Chrome<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Tips/" title="Tips">Tips<sup>3</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://laod.cn/hosts/2017-google-hosts.html" target="_blank" title="Google Hosts">Google Hosts</a>
            
          </li>
        
          <li>
            
            	<a href="http://overapi.com" target="_blank" title="OverAPI">OverAPI</a>
            
          </li>
        
          <li>
            
            	<a href="https://devdocs.io" target="_blank" title="DevDocs">DevDocs</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>

    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> 善良   善学   勇敢   坚毅 <br/>
			努力   克制   谦虚   执着</p>
	</section>
	 
	<div id="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">Hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="FlamePeak">FlamePeak</a>
		
		





		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
        getSize();
        if (myWidth >= 1024) {
          $('#toc.toc-aside').css('display', 'block');
          c.click();
        }
  
  $(window).resize(function(){
    getSize();
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
      
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});
</script>











<!-- Analytics Begin -->
<!--%- partial('analytics') %-->
<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>

