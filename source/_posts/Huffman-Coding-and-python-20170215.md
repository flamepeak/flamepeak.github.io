---
title: 霍夫曼编码 原理与实现
date: 2017-02-15 21:46:21
tags: [Python, C]
categories: [Python]
mathjax: true
---

霍夫曼编码（Huffman Coding）,又称为哈夫曼编码，是一种用于无损数据压缩的熵编码算法。一种能够使用最短的位数来编码被编码文件的前缀码；

霍夫曼编码使用**变长编码表**对源符号进行编码，其中变长编码表是通过一种评估来源符号出现概率的方法得到的，**出现概率高的字母使用较短的编码，出现概率低的则使用较长的编码**。

例如，在英文中，e的出现概率最高，而z的出现概率则最低。当利用霍夫曼编码对一篇英文进行压缩时，e极有可能用一个比特来表示，而z则可能花去25个比特（不是26）。用普通的表示方法时，每个英文字母均占用一个字节，即8个比特。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。

霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为 $WPL=（W_1*L_1+W_2*L_2+W_3*L_3+...+W_n*L_n）$，$N$个权值$W_i$（$i=1,2,...n$）构成一棵有$N$个叶结点的二叉树，相应的叶结点的路径长度为$L_i$（$i=1,2,...n$）。可以证明霍夫曼树的WPL是最小的。

霍夫曼树常处理符号编写工作。根据整组数据中符号出现的频率高低，决定如何给符号编码。如果符号出现的频率越高，则给符号的码越短，相反符号的号码越长。

霍夫曼编码的动态演示如下图所示。基本步骤是将出现频率由小到大排列，组成子树后频率相加作为整体再和其他未加入二叉树中的节点频率比较。加权路径长为节点的频率乘以树的深度。

![Huffman_algorithm.gif](/sourcepictures/2017/02/15/Huffman_algorithm.gif)

![TABLE8.JPG](/sourcepictures/2017/02/15/TABLE8.JPG)

更多请参考阅读： [HUFFMAN 编码压缩算法](https://coolshell.cn/articles/7459.html)